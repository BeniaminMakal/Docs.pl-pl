---
title: Pochodnym podkluczy i uwierzytelnionego szyfrowania w ASP.NET Core
author: rick-anderson
description: Dowiedz się szczegóły implementacji ochrony danych platformy ASP.NET Core podkluczy pochodnym i uwierzytelniony szyfrowania.
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 8c83da40a524896becc07c94c01d5e2b684e4386
ms.sourcegitcommit: 48beecfe749ddac52bc79aa3eb246a2dcdaa1862
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/22/2018
ms.locfileid: "30072642"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="4ebd5-103">Pochodnym podkluczy i uwierzytelnionego szyfrowania w ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="4ebd5-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="4ebd5-104">Większość klawiszy w kręgu klucz będzie zawierać jakiegoś entropii i będzie miał informacji algorytmicznego, podając "szyfrowania w trybie CBC + weryfikacji HMAC" lub "szyfrowania GCM + Walidacja".</span><span class="sxs-lookup"><span data-stu-id="4ebd5-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="4ebd5-105">W takich przypadkach nazywamy osadzonych entropii materiał klucza głównego (lub KM) dla tego klucza, a wykonać funkcja wyprowadzania klucza do tworzenia kluczy, które będą używane dla operacje kryptograficzne.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="4ebd5-106">Klucze są abstrakcyjny, a implementacja niestandardowa może nie działać zgodnie z poniższymi instrukcjami.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="4ebd5-107">Jeśli klucz udostępnia własną implementację `IAuthenticatedEncryptor` zamiast przy użyciu jednej z naszych fabryki wbudowanych, mechanizm opisane w tej sekcji nie ma już zastosowania.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="4ebd5-108">Dodatkowe dane uwierzytelnionych i podkluczy wyprowadzania</span><span class="sxs-lookup"><span data-stu-id="4ebd5-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="4ebd5-109">`IAuthenticatedEncryptor` Interfejsu służy jako interfejs core dla wszystkich operacji szyfrowania uwierzytelniony.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="4ebd5-110">Jego `Encrypt` metoda przyjmuje dwa buforów: zwykłego tekstu i additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="4ebd5-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="4ebd5-111">Przepływ zawartości w postaci zwykłego tekstu bez zmian wywołanie `IDataProtector.Protect`, ale usługi AAD jest generowany przez system i składa się z trzech składników:</span><span class="sxs-lookup"><span data-stu-id="4ebd5-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="4ebd5-112">Nagłówek magic 32-bitowych 09 F0 C9 F0, która identyfikuje tę wersję systemu ochrony danych.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="4ebd5-113">Identyfikator klucza 128-bitowego.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="4ebd5-114">Sformatowany ciąg o zmiennej długości z łańcucha cel, który utworzony `IDataProtector` wykonuje tę operację.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="4ebd5-115">Usługi AAD jest unikatowy dla wszystkich trzech komponentów spójnej kolekcji, możemy użyć go do uzyskania nowych kluczy z km, który zamiast km, który sam we wszystkich naszych operacji kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="4ebd5-116">Dla każdego wywołania `IAuthenticatedEncryptor.Encrypt`, odbywa się następujący proces wyprowadzania klucza:</span><span class="sxs-lookup"><span data-stu-id="4ebd5-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="4ebd5-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (contextHeader K_M, AAD, || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="4ebd5-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="4ebd5-118">W tym miejscu dzwonimy KDF SP800 108 NIST w trybie licznika (zobacz [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), 5.1 s.) z następującymi parametrami:</span><span class="sxs-lookup"><span data-stu-id="4ebd5-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="4ebd5-119">Klucz klucza pochodnego (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="4ebd5-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="4ebd5-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="4ebd5-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="4ebd5-121">Etykieta = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="4ebd5-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="4ebd5-122">kontekst = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="4ebd5-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="4ebd5-123">Nagłówek kontekstu jest o zmiennej długości i zasadniczo służy jako odcisk palca algorytmów, dla których firma Microsoft w przypadku tworzenia klasy pochodnej K_E i K_H.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="4ebd5-124">Modyfikator klucza jest ciągiem 128-bitowego, losowo wygenerowany dla każdego wywołania `Encrypt` i służy do zapewnienia przeciążając uda się rozpoznać prawdopodobieństwo, że KE i KH unikatowy dla tej operacji szyfrowania określonego uwierzytelniania, nawet jeśli wszystkie inne dane wejściowe KDF jest stałą.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="4ebd5-125">W trybie CBC szyfrowania + HMAC operacji sprawdzania poprawności | K_E | długość klucza szyfrowania symetrycznego bloku i | K_H | jest rozmiarem skrótu HMAC procedury.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="4ebd5-126">Do szyfrowania GCM + operacji sprawdzania poprawności | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="4ebd5-127">Szyfrowanie w trybie CBC + HMAC weryfikacji</span><span class="sxs-lookup"><span data-stu-id="4ebd5-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="4ebd5-128">Wygenerowany K_E za pośrednictwem mechanizmu powyżej firma Microsoft wektor inicjowania losowe generowanie i uruchom algorytmu szyfrowania symetrycznego bloku do encipher w formie zwykłego tekstu.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="4ebd5-129">Wektor inicjowania i tekstu szyfrowanego następnie uruchom za pomocą procedury HMAC zainicjowany z kluczem K_H w celu utworzenia komputerów MAC.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="4ebd5-130">Ten proces i wartość zwracana jest reprezentowane graficznie poniżej.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-130">This process and the return value is represented graphically below.</span></span>

![Proces w trybie CBC i wróć](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="4ebd5-132">*dane wyjściowe: = keyModifier || IV || E_cbc (dane K_E, iv) || Metoda HMAC (K_H, iv || E_cbc (dane K_E, iv))*</span><span class="sxs-lookup"><span data-stu-id="4ebd5-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="4ebd5-133">`IDataProtector.Protect` Będzie implementacji [dołączy nagłówku magic i identyfikator klucza](xref:security/data-protection/implementation/authenticated-encryption-details) danych wyjściowych przed zwróceniem jej do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="4ebd5-134">Ponieważ magic nagłówka i identyfikator klucza niejawnie są częścią [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), i ponieważ modyfikator klucza jest podawany jako dane wejściowe KDF, oznacza to, że każdy pojedynczy bajt końcowy ładunek zwracane jest uwierzytelniany przez komputerów MAC.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="4ebd5-135">Tryb Galois liczników szyfrowania + sprawdzania poprawności</span><span class="sxs-lookup"><span data-stu-id="4ebd5-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="4ebd5-136">Wygenerowany K_E za pośrednictwem mechanizmu powyżej firma Microsoft generowania losowego nonce 96-bitowej, a następnie uruchom algorytmu szyfrowania symetrycznego bloku encipher w postaci zwykłego tekstu i utworzyć tag uwierzytelniania 128-bitowego.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Proces trybu GCM i wróć](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="4ebd5-138">*dane wyjściowe: = keyModifier || Identyfikator jednorazowy || E_gcm (K_E, nonce, dane) || authTag*</span><span class="sxs-lookup"><span data-stu-id="4ebd5-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="4ebd5-139">Mimo że GCM natywnie obsługuje pojęcie usługi AAD, firma Microsoft jest nadal zasilania AAD tylko do oryginalnego KDF, aby przekazać pusty ciąg do usługi GCM jej parametru usługi AAD.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="4ebd5-140">Przyczyną tego jest dwukrotne.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-140">The reason for this is two-fold.</span></span> <span data-ttu-id="4ebd5-141">Najpierw [do obsługi elastyczność](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) nigdy nie chcemy użyć K_M bezpośrednio jako klucza szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="4ebd5-142">Ponadto usługi GCM nakłada bardzo rygorystyczny unikatowość wymagania dotyczące jej danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="4ebd5-143">Prawdopodobieństwo, że procedura szyfrowania GCM jest kiedykolwiek wywołana na dwóch lub więcej różne zestawy danych wejściowych o takiej samej (klucz, nonce) pary nie może przekraczać 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="4ebd5-144">Jeśli firma Microsoft rozwiąże K_E nie można wykonać więcej niż 2 ^ 32 operacji szyfrowania przed możemy uruchomić afoul o 2 ^ ograniczyć -32.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="4ebd5-145">To może się wydawać bardzo dużej liczby operacji, ale serwer sieci web o dużym natężeniu ruchu przejść przez kolejne żądania 4 miliardy w zwykłe dni, również w obrębie użytkowania tych kluczy.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="4ebd5-146">Aby pozostać zgodne 2 ^ limit prawdopodobieństwo-32 w dalszym ciągu używać 128-bitowego klucza modyfikator i identyfikator jednorazowy 96-bitowej, które znacząco rozszerza liczbę operacji można używać na dowolnym danym K_M.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="4ebd5-147">Dla uproszczenia projektowania firma Microsoft udostępnia ścieżkę kodu KDF między operacjami CBC i GCM, a ponieważ AAD jest już uznawana za w KDF nie jest konieczne ją przesłać do procedury usługi GCM.</span><span class="sxs-lookup"><span data-stu-id="4ebd5-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
